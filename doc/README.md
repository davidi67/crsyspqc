<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# crsyspqc

```go
import "github.com/davidi67/crsyspqc"
```

Package crsyspqc provides an interface to CryptoSys PQC for go programmers.

CryptoSys PQC provides Post\-Quantum Cryptography algorithms as specified by NIST. Requires CryptoSys PQC to be installed on your computer, available for free at https://www.cryptosys.net/pqc/

References:

- [FIPS203](<https://doi.org/10.6028/NIST.FIPS.203>) Module\-Lattice\-based Key\-Encapsulation Mechanism Standard
- [FIPS204](<https://doi.org/10.6028/NIST.FIPS.204>) Module\-Lattice\-Based Digital Signature Standard
- [FIPS205](<https://doi.org/10.6028/NIST.FIPS.205>) Stateless Hash\-Based Digital Signature Standard

## Index

- [type Dsa](<#Dsa>)
  - [func \(d Dsa\) AlgName\(alg DsaAlg\) string](<#Dsa.AlgName>)
  - [func \(d Dsa\) KeyGen\(alg DsaAlg\) \(pk \[\]byte, sk \[\]byte, err error\)](<#Dsa.KeyGen>)
  - [func \(d Dsa\) KeyGenWithParams\(alg DsaAlg, params string\) \(pk \[\]byte, sk \[\]byte, err error\)](<#Dsa.KeyGenWithParams>)
  - [func \(d Dsa\) LookupAlgByName\(s string\) \(alg DsaAlg, err error\)](<#Dsa.LookupAlgByName>)
  - [func \(d Dsa\) PrivateKeySize\(alg DsaAlg\) int](<#Dsa.PrivateKeySize>)
  - [func \(d Dsa\) PublicKeyFromPrivate\(alg DsaAlg, sk \[\]byte\) \(pk \[\]byte, err error\)](<#Dsa.PublicKeyFromPrivate>)
  - [func \(d Dsa\) PublicKeySize\(alg DsaAlg\) int](<#Dsa.PublicKeySize>)
  - [func \(d Dsa\) Sign\(alg DsaAlg, msg \[\]byte, privatekey \[\]byte\) \(sig \[\]byte, err error\)](<#Dsa.Sign>)
  - [func \(d Dsa\) SignEx\(alg DsaAlg, msg \[\]byte, privatekey \[\]byte, opts SigOpts, context \[\]byte, params string\) \(sig \[\]byte, err error\)](<#Dsa.SignEx>)
  - [func \(d Dsa\) SignPreHash\(alg DsaAlg, msg \[\]byte, hashAlg PreHashAlg, privatekey \[\]byte, opts SigOpts, context \[\]byte, params string\) \(sig \[\]byte, err error\)](<#Dsa.SignPreHash>)
  - [func \(d Dsa\) SignatureSize\(alg DsaAlg\) int](<#Dsa.SignatureSize>)
  - [func \(d Dsa\) Verify\(alg DsaAlg, sig \[\]byte, msg \[\]byte, publickey \[\]byte\) \(ok bool, err error\)](<#Dsa.Verify>)
  - [func \(d Dsa\) VerifyEx\(alg DsaAlg, sig \[\]byte, msg \[\]byte, publickey \[\]byte, opts SigOpts, context \[\]byte\) \(ok bool, err error\)](<#Dsa.VerifyEx>)
  - [func \(d Dsa\) VerifyPreHash\(alg DsaAlg, sig \[\]byte, msg \[\]byte, hashAlg PreHashAlg, publickey \[\]byte, opts SigOpts, context \[\]byte\) \(ok bool, err error\)](<#Dsa.VerifyPreHash>)
- [type DsaAlg](<#DsaAlg>)
- [type General](<#General>)
  - [func \(g General\) DllInfo\(\) string](<#General.DllInfo>)
  - [func \(g General\) Version\(\) int](<#General.Version>)
- [type Kem](<#Kem>)
  - [func \(k Kem\) AlgName\(alg KemAlg\) string](<#Kem.AlgName>)
  - [func \(k Kem\) CipherTextSize\(alg KemAlg\) int](<#Kem.CipherTextSize>)
  - [func \(k Kem\) DecapKeySize\(alg DsaAlg\) int](<#Kem.DecapKeySize>)
  - [func \(k Kem\) Decaps\(alg KemAlg, ct \[\]byte, dk \[\]byte\) \(ss \[\]byte, err error\)](<#Kem.Decaps>)
  - [func \(k Kem\) EncapKeySize\(alg KemAlg\) int](<#Kem.EncapKeySize>)
  - [func \(k Kem\) Encaps\(alg KemAlg, ek \[\]byte\) \(ss \[\]byte, ct \[\]byte, err error\)](<#Kem.Encaps>)
  - [func \(k Kem\) EncapsWithParams\(alg KemAlg, ek \[\]byte, params string\) \(ss \[\]byte, ct \[\]byte, err error\)](<#Kem.EncapsWithParams>)
  - [func \(k Kem\) KeyGen\(alg KemAlg\) \(ek \[\]byte, dk \[\]byte, err error\)](<#Kem.KeyGen>)
  - [func \(k Kem\) KeyGenWithParams\(alg KemAlg, params string\) \(ek \[\]byte, dk \[\]byte, err error\)](<#Kem.KeyGenWithParams>)
  - [func \(k Kem\) LookupAlgByName\(s string\) \(alg KemAlg, err error\)](<#Kem.LookupAlgByName>)
  - [func \(k Kem\) SharedKeySize\(alg KemAlg\) int](<#Kem.SharedKeySize>)
- [type KemAlg](<#KemAlg>)
- [type PreHashAlg](<#PreHashAlg>)
- [type SigOpts](<#SigOpts>)


<a name="Dsa"></a>
## type Dsa

Dsa provides methods to generate keys, sign and verify with the DSA algorithms.

```go
type Dsa struct{}
```

<a name="Dsa.AlgName"></a>
### func \(Dsa\) AlgName

```go
func (d Dsa) AlgName(alg DsaAlg) string
```

AlgName gets the algorithm name from its code

<a name="Dsa.KeyGen"></a>
### func \(Dsa\) KeyGen

```go
func (d Dsa) KeyGen(alg DsaAlg) (pk []byte, sk []byte, err error)
```

Generate a DSA signing key pair \(pk, sk\)

<a name="Dsa.KeyGenWithParams"></a>
### func \(Dsa\) KeyGenWithParams

```go
func (d Dsa) KeyGenWithParams(alg DsaAlg, params string) (pk []byte, sk []byte, err error)
```

Generate a DSA signing key pair \(pk, sk\) passing known randomness encoded in hex

<a name="Dsa.LookupAlgByName"></a>
### func \(Dsa\) LookupAlgByName

```go
func (d Dsa) LookupAlgByName(s string) (alg DsaAlg, err error)
```

LookupAlgByName gets the algorithm code from its name.

NB is case sensitive, expects dash "\-" not underscore. For example

```
var dsa crsyspqc.Dsa
alg, err = dsa.LookupAlgByName("SLH-DSA-SHAKE-256s")
```

<a name="Dsa.PrivateKeySize"></a>
### func \(Dsa\) PrivateKeySize

```go
func (d Dsa) PrivateKeySize(alg DsaAlg) int
```

Return length in bytes of \(expanded\) private key for the given DSA algorithm.

<a name="Dsa.PublicKeyFromPrivate"></a>
### func \(Dsa\) PublicKeyFromPrivate

```go
func (d Dsa) PublicKeyFromPrivate(alg DsaAlg, sk []byte) (pk []byte, err error)
```

Extract the public key from a private key

<a name="Dsa.PublicKeySize"></a>
### func \(Dsa\) PublicKeySize

```go
func (d Dsa) PublicKeySize(alg DsaAlg) int
```

PublicKeySize returns length in bytes of public key for the given DSA algorithm.

```
var dsa crsyspqc.Dsa
fmt.Println(dsa.PublicKeySize(crsyspqc.ML_DSA_65))  // 1952
```

<a name="Dsa.Sign"></a>
### func \(Dsa\) Sign

```go
func (d Dsa) Sign(alg DsaAlg, msg []byte, privatekey []byte) (sig []byte, err error)
```

Generate a DSA signature over a message Default options: hedged with fresh randomness, no context

<a name="Dsa.SignEx"></a>
### func \(Dsa\) SignEx

```go
func (d Dsa) SignEx(alg DsaAlg, msg []byte, privatekey []byte, opts SigOpts, context []byte, params string) (sig []byte, err error)
```

Generate a DSA signature over a message with extended options.

- [SigOpts](<#SigOpts>): to set alternative mode for signing \(default hedged with fresh randomness\).
- context: pass a context value \(pass nil for no context\).
- params: pass a known random test value in params \(encoded in hex\) \- hedged mode only \(pass "" to ignore\).

<a name="Dsa.SignPreHash"></a>
### func \(Dsa\) SignPreHash

```go
func (d Dsa) SignPreHash(alg DsaAlg, msg []byte, hashAlg PreHashAlg, privatekey []byte, opts SigOpts, context []byte, params string) (sig []byte, err error)
```

Generate a DSA signature over a pre\-hashed message

<a name="Dsa.SignatureSize"></a>
### func \(Dsa\) SignatureSize

```go
func (d Dsa) SignatureSize(alg DsaAlg) int
```

Return length in bytes of signature for the given DSA algorithm

<a name="Dsa.Verify"></a>
### func \(Dsa\) Verify

```go
func (d Dsa) Verify(alg DsaAlg, sig []byte, msg []byte, publickey []byte) (ok bool, err error)
```

Verify a DSA signature: default options, no context

Returns true if the signature is valid over the message, else false. Returns a non\-nil err if a parameter is wrong.

<a name="Dsa.VerifyEx"></a>
### func \(Dsa\) VerifyEx

```go
func (d Dsa) VerifyEx(alg DsaAlg, sig []byte, msg []byte, publickey []byte, opts SigOpts, context []byte) (ok bool, err error)
```

Verify a DSA signature over a message. Extended options.

<a name="Dsa.VerifyPreHash"></a>
### func \(Dsa\) VerifyPreHash

```go
func (d Dsa) VerifyPreHash(alg DsaAlg, sig []byte, msg []byte, hashAlg PreHashAlg, publickey []byte, opts SigOpts, context []byte) (ok bool, err error)
```

Verify a DSA signature over a pre\-hashed message. Pass the hash digest as the message and specify the hash algorithm used

<a name="DsaAlg"></a>
## type DsaAlg

DsaAlg enumerates the provided DSA algorithms

```go
type DsaAlg int
```

<a name="ML_DSA_44"></a>

```go
const (
    ML_DSA_44          DsaAlg = 0x20 // ML-DSA-44 from FIPS.204 (based on Dilithium2)
    ML_DSA_65          DsaAlg = 0x21 // ML-DSA-65 from FIPS.204 (based on Dilithium3)
    ML_DSA_87          DsaAlg = 0x22 // ML-DSA-87 from FIPS.204 (based on Dilithium5)
    SLH_DSA_SHA2_128S  DsaAlg = 0x32 // SLH-DSA-SHA2-128s from FIPS.205
    SLH_DSA_SHA2_128F  DsaAlg = 0x33 // SLH-DSA-SHA2-128f from FIPS.205
    SLH_DSA_SHA2_192S  DsaAlg = 0x34 // SLH-DSA-SHA2-192s from FIPS.205
    SLH_DSA_SHA2_192F  DsaAlg = 0x35 // SLH-DSA-SHA2-192f from FIPS.205
    SLH_DSA_SHA2_256S  DsaAlg = 0x36 // SLH-DSA-SHA2-256s from FIPS.205
    SLH_DSA_SHA2_256F  DsaAlg = 0x37 // SLH-DSA-SHA2-256f from FIPS.205
    SLH_DSA_SHAKE_128S DsaAlg = 0x3A // SLH-DSA-SHAKE-128s from FIPS.205
    SLH_DSA_SHAKE_128F DsaAlg = 0x3B // SLH-DSA-SHAKE-128f from FIPS.205
    SLH_DSA_SHAKE_192S DsaAlg = 0x3C // SLH-DSA-SHAKE-192s from FIPS.205
    SLH_DSA_SHAKE_192F DsaAlg = 0x3D // SLH-DSA-SHAKE-192f from FIPS.205
    SLH_DSA_SHAKE_256S DsaAlg = 0x3E // SLH-DSA-SHAKE-256s from FIPS.205
    SLH_DSA_SHAKE_256F DsaAlg = 0x3F // SLH-DSA-SHAKE-256f from FIPS.205
)
```

<a name="General"></a>
## type General

General has methods that provide diagnostic info about the core native DLL.

```go
type General struct{}
```

<a name="General.DllInfo"></a>
### func \(General\) DllInfo

```go
func (g General) DllInfo() string
```

DllInfo returns information about the core native DLL.

For example

```
"Platform=X64;Compiled=Apr 2 2025 19:13:31;Licence=T"
```

<a name="General.Version"></a>
### func \(General\) Version

```go
func (g General) Version() int
```

Version returns the version number of core native diCrPQC DLL An integer of the form Major \* 10000 \+ Minor \* 100 \+ Release

```
var general crsyspqc.General
fmt.Println(general.Version())  // 10000
```

<a name="Kem"></a>
## type Kem

Kem provides methods to generate KEM keys, and perform key encapsulation and decapsulation.

```go
type Kem struct{}
```

<a name="Kem.AlgName"></a>
### func \(Kem\) AlgName

```go
func (k Kem) AlgName(alg KemAlg) string
```

Get the algorithm name from its code

<a name="Kem.CipherTextSize"></a>
### func \(Kem\) CipherTextSize

```go
func (k Kem) CipherTextSize(alg KemAlg) int
```

Return length in bytes of ciphertext \(ct / C\) for the given KEM algorithm.

<a name="Kem.DecapKeySize"></a>
### func \(Kem\) DecapKeySize

```go
func (k Kem) DecapKeySize(alg DsaAlg) int
```

Return length in bytes of expanded decapsulation key \("private key"\) for the given KEM algorithm.

<a name="Kem.Decaps"></a>
### func \(Kem\) Decaps

```go
func (k Kem) Decaps(alg KemAlg, ct []byte, dk []byte) (ss []byte, err error)
```

Carry out the ML\-KEM decapsulation algorithm: \(ss'\)\<\-\-Decaps\(ct, dk\)

<a name="Kem.EncapKeySize"></a>
### func \(Kem\) EncapKeySize

```go
func (k Kem) EncapKeySize(alg KemAlg) int
```

Return length in bytes of the encapsulation \("public"\) key \`ek\` for the KEM algorithm \`KemAlg\`

<a name="Kem.Encaps"></a>
### func \(Kem\) Encaps

```go
func (k Kem) Encaps(alg KemAlg, ek []byte) (ss []byte, ct []byte, err error)
```

Carry out the ML\-KEM encapsulation algorithm: \(ss,ct\)\<\-\-Encaps\(ek\)

<a name="Kem.EncapsWithParams"></a>
### func \(Kem\) EncapsWithParams

```go
func (k Kem) EncapsWithParams(alg KemAlg, ek []byte, params string) (ss []byte, ct []byte, err error)
```

Carry out the ML\-KEM encapsulation algorithm: \(ss,ct\)\<\-\-Encaps\(ek\)

- Use "params" to pass a known test random seed encoded in hex and representing exactly 32 bytes.

<a name="Kem.KeyGen"></a>
### func \(Kem\) KeyGen

```go
func (k Kem) KeyGen(alg KemAlg) (ek []byte, dk []byte, err error)
```

Generate an encapsulation/decapsulation key pair \(ek, dk\)\<\-\-KeyGen\(\)

<a name="Kem.KeyGenWithParams"></a>
### func \(Kem\) KeyGenWithParams

```go
func (k Kem) KeyGenWithParams(alg KemAlg, params string) (ek []byte, dk []byte, err error)
```

Generate an encapsulation/decapsulation key pair passing known randomness encoded in hex

<a name="Kem.LookupAlgByName"></a>
### func \(Kem\) LookupAlgByName

```go
func (k Kem) LookupAlgByName(s string) (alg KemAlg, err error)
```

Get the algorithm code from its name.

NB case sensitive, expects dash "\-" not underscore

<a name="Kem.SharedKeySize"></a>
### func \(Kem\) SharedKeySize

```go
func (k Kem) SharedKeySize(alg KemAlg) int
```

Return length in bytes of the shared key \(ss, K\) for the given KEM algorithm.

<a name="KemAlg"></a>
## type KemAlg

KemAlg enumerates the available KEM algroithms

```go
type KemAlg int
```

<a name="ML_KEM_512"></a>

```go
const (
    ML_KEM_512  KemAlg = 0x10 // ML_KEM_512 from FIPS.203 (based on Kyber512)
    ML_KEM_768  KemAlg = 0x11 // ML_KEM_768 from FIPS.203 (based on Kyber768)
    ML_KEM_1024 KemAlg = 0x12 // ML_KEM_1024 from FIPS.203 (based on Kyber1024)
)
```

<a name="PreHashAlg"></a>
## type PreHashAlg

Hash function identifiers for pre\-hash signing

```go
type PreHashAlg int
```

<a name="SHA256"></a>

```go
const (
    SHA256       PreHashAlg = 0x1 // SHA-256 from FIPS.180-4
    SHA384       PreHashAlg = 0x2 // SHA-284 from FIPS.180-4
    SHA512       PreHashAlg = 0x3 // SHA-512 from FIPS.180-4
    SHA224       PreHashAlg = 0x4 // SHA-224 from FIPS.180-4
    SHA512_224   PreHashAlg = 0x5 // SHA-512/224 from FIPS.180-4
    SHA512_256   PreHashAlg = 0x6 // SHA-512/256 from FIPS.180-4
    SHA3_224     PreHashAlg = 0x7 // SHA3-224 from FIPS.202
    SHA3_256     PreHashAlg = 0x8 // SHA3-256 from FIPS.202
    SHA3_384     PreHashAlg = 0x9 // SHA3-384 from FIPS.202
    SHA3_512     PreHashAlg = 0xA // SHA3-512 from FIPS.202
    SHAKE128_256 PreHashAlg = 0xB // SHAKE-128-256 from FIPS.202
    SHAKE256_512 PreHashAlg = 0xC // SHAKE-256-512 from FIPS.202
)
```

<a name="SigOpts"></a>
## type SigOpts

Signature options for DSA

```go
type SigOpts int
```

<a name="SIGOPTS_DEFAULT"></a>

```go
const (
    SIGOPTS_DEFAULT SigOpts = 0         // Default signing options (hedged with fresh randomness)
    DETERMINISTIC   SigOpts = 0x2000    // Use deterministic variant when signing
    INTERNAL        SigOpts = 0x4000000 // Use Sign_internal or Verify_internal algorithm (for testing purposes)
    EXTERNALMU      SigOpts = 0x8000000 // Use ExternalMu-ML-DSA.Sign or ExternalMu-ML-DSA.Verify algorithm (ML-DSA only)
)
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
